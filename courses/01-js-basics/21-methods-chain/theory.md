Основы JavaScript

# Цепочка вызовов

У чисел есть метод, который преобразует их в строку:

```javascript
const peopleCount = 5;
peopleCount.toString(); // 5
```

Заработает ли следующий код — и если да, то что он напечатает на экран?

```javascript
const name = 'Tirion';
console.log(name.length.toString());
```

В этом коде произошло объединение уже известных возможностей языка.

Простой способ понять, как работает этот код — разбить цепочку на отдельные операции:

```javascript
const name = 'Tirion';
const len = name.length;
console.log(len.toString());
```

Эти примеры эквивалентны. Мы можем выполнять операции последовательно с промежуточным созданием констант или строить непрерывную цепочку из свойств и методов. В цепочках вычисления всегда идут слева направо.

```javascript
const name = 'Tirion';
console.log(name.toUpperCase().toLowerCase());
```

Важно: `.toLowerCase()` применяется к результату вызова метода, который находится левее. А метод `toUpperCase()` возвращает строку. Частая ошибка новичков - не поставить вызов:

```javascript
const name = 'Tirion';
// Этот код отработает неверно!
console.log(name.toUpperCase.toLowerCase());
```

Возможно строить бесконечно длинные цепочки:

```javascript
// Чему равен результат такого вызова?
console.log(name.toUpperCase().toLowerCase().length.toString().length);
```

С функциями подобный трюк не сработает, так как при обычном использовании они вкладываются друг в друга `f(f(f()))`, что значительно ухудшает анализ. Но это не значит, что нельзя сделать красиво — можно и даже нужно. В других языках это реализуется через композицию функций или пайплайн-оператор. Кстати говоря, он постепенно начинает использоваться и в самом JavaScript: https://github.com/tc39/proposal-pipeline-operator
