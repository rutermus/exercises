JS: Введение в ООП

# Инкапсуляция

**Инкапсуляция** – это объединение функций и данных в рамках одной структуры, внутреннее состояние которой (данные) скрыто от внешнего мира (этот аспект мы разберем позже). Такие функции называют методами.

**Сложно**

Перед изучением инкапсуляции обсудим терминологию, которая вызывает путаницу среди разработчиков.

Иногда под инкапсуляцией понимают сокрытие данных (data hiding) от прямого внешнего обращения (обычно с помощью ключевых слов private, protected). Возможно, именно это определение захотят от вас услышать на собеседовании, но оно правильно лишь частично. Стоит разделять объединение данных с методами и сокрытие этих данных. Есть языки (Python), в которых есть объединение данных, но нет сокрытия данных. Причем если в этих языках ввести сокрытие данных, то архитектура программ не изменится, но если разъединить данные и методы, то придется переписывать весь код. Аналогичная картина с языками, в которых есть сокрытие данных. Убрав его мало что измениться, но разработчикам придется быть аккуратнее при работе с объектами.

Подводя итог: инкапсуляция это и объединение, и сокрытие там, где оно есть. Где его нет, это просто объединение. В курсе разделены понятия инкапсуляции (объединение данных и функций) и сокрытия данных, для возможности обсуждения этих особенностей независимо.

**Конец Сложно :)**

```javascript
// Вызов метода
user.getName();

// Вызов функции
getName(user);
```

Рассмотрим внешние особенности методов.

Работа с методами вместо функций дает возможность реализовать автодополнение методов в редакторах. Говорят, эта особенность методов стала причиной популярности ООП.

В языках с развитой системой модулей автодополнение есть и при работе с обычными функциями. Но в любом случае сначала нужно написать правильное имя модуля. Пример из эликсира: `User.getName(user)`. Также существуют языки с `Unified Function Call` (например `Nim`), где обычные функции можно вызывать как методы и получать автодополнение.

Другая особенность достаточно противоречивая. Для многих разработчиков код с методами выглядит "естественнее". С их точки зрения, абстракции с помощью данных можно строить только на базе методов. Если не объединять данные и функции в одном месте, то абстракция невозможна. Такое восприятие возникает из-за ограниченного опыта. Как правило, такой разработчик никогда не работал за пределами популярных ООП-языков и в его языке абстракции на функциях противоестественны и даже невозможны.

Это не так. Достаточно пройти курс JS: Абстракции с помощью данных и убедиться в этом. Абстракции и моделирование реального мира существуют не только в ООП. Они существовали до и будут существовать после.

Представьте добавление в друзья в ООП-стиле. Кто кого должен добавить (первый друг второго или второй первого) и как не допустить рекурсии при взаимном добавлении?

Третья особенность методов интереснее. Она делает работу с кодом проще, а код короче. При работе с объектами нам не надо ничего дополнительно импортировать, как в случае с функциями. Любая функция, в которую был передан объект, может вызывать его методы так, как она хочет. Если бы мы работали с функциями, то нам бы пришлось дополнительно импортировать нужные функции. Эта особенность не дается бесплатно, она ограничивает расширение объектов (об этом в следующих уроках).

```javascript
// send просто функция, поэтому ее надо импортировать перед использованием
import send from 'mail';

const sendEmail = (user) => {
  send('Subject', user.getEmail()); // Не надо импортировать getEmail потому что это метод
};
```

А что делать, когда объекта нет, как в примере выше? В JS функции и методы спокойно уживаются вместе. Примерно то же самое происходит в Python. В Ruby и PHP (в современных фреймворках) обычные функции выглядят уже не так естественно, хотя их по-прежнему можно создавать. В Java вообще нет возможности создавать обычные функции. Любая функция будет методом. Поэтому в Java объекты создают практически на каждый чих. Это значительно раздувает программу и усложняет реализацию простых вещей. В Elixir и Clojure методов в текущем понимании просто нет - они там просто не нужны, а код при этом лаконичный, простой и расширяемый.

Для имитации обычных функций в Java используют статические методы. Они позволяют работать без создания объектов.

Четвертая особенность – цепочки. Вспомните такой вызов:

```javascript
const brand = 'bmw';
// Этот метод не изменяет строку, а возвращает новую!
brand.toUpperCase(); // BMW
```

Этот метод возвращает новую строку, у которой тоже есть методы, а значит их можно вызвать:

```javascript
// Переменная, так как перезаписываем
let brand = 'bmw';
brand = brand.toUpperCase(); // BMW
brand = brand.concat(' & Kia'); // BMW & Kia
brand = brand.replace('BMW', 'Opel'); // Opel & Kia
console.log(brand); // => Opel & Kia
```

Тоже самое без создания промежуточных переменных:

```javascript
const brand = 'bmw';
// Теперь лучше сделать новую константу, вместо переменной
const newBrand = brand.toUpperCase().concat(' & Kia').replace('BMW', 'Opel');
console.log(newBrand); // => Opel & Kia
```

Код получился компактнее и понятнее. Легко перейти границу - не увлекайтесь. Код можно разбить на несколько строк:

```javascript
const brand = 'bmw';
const newBrand = brand
  .toUpperCase() //
  .concat(' & Kia')
  .replace('BMW', 'Opel');
console.log(newBrand); // => Opel & Kia
```

Такие цепочки можно строить, даже если возвращается значение другого типа. В таком случае можно применять методы соответствующего типа:

```javascript
const brand = 'bmw';
const newBrand = brand
  .toUpperCase()
  .split('') // ['B', 'M', 'W']
  .reverse() // ['W', 'M', 'B']
  .join(''); // WMB
console.log(newBrand); // => WMB
```

У таких цепочек есть специальное имя: `fluent interface`

Как и практически все остальное в современном понимании ООП, цепочки не являются чем-то эксклюзивным. Более того, они повторяют такую вещь, как пайплайн (pipeline). Если вы знакомы с командной строкой, то скорее всего не раз видели такой код:

```sh
# | называется пайпом (pipe - труба)
# Пайплайн часто сравнивают с бусинками (функции), через которые пропускают веревку (данные).
cat sample | grep -v a | sort -r
```

Эта цепочка команд последовательно передает данные слева направо, пропуская их сквозь разные обработчики. Такая концепция пришла из математики и появилась задолго до программирования. Во многих языках пайплайн реализован как языковая конструкция (либо макрос в Lisp). Прямо сейчас пайплайн находится в стадии рассмотрения в JavaScript. Посмотрите пример:

```javascript
// Так с функциями работать неудобно
const result = exclaim(capitalize(doubleSay('hello')));
console.log(result); // => "Hello, hello!"

// А вот это совсем другое дело (но нужно привыкнуть)
// |> – это пайп, он отправляет данные, пришедшие слева в функцию справа
const result =
  'hello'
  |> doubleSay //
  |> capitalize
  |> exclaim;

console.log(result); // => "Hello, hello!"
```
